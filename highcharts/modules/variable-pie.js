!/**
 * Highcharts JS v12.0.1 (2024-11-28)
 * @module highcharts/modules/variable-pie
 * @requires highcharts
 *
 * Variable Pie module for Highcharts
 *
 * (c) 2010-2024 Grzegorz Blachliński
 *
 * License: www.highcharts.com/license
 */function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("highcharts"),require("highcharts").SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/variable-pie",[["highcharts/highcharts"],["highcharts/highcharts","SeriesRegistry"]],e):"object"==typeof exports?exports["highcharts/variable-pie"]=e(require("highcharts"),require("highcharts").SeriesRegistry):t.Highcharts=e(t.Highcharts,t.Highcharts.SeriesRegistry)}(this,(t,e)=>(()=>{"use strict";var i={512:t=>{t.exports=e},944:e=>{e.exports=t}},r={};function a(t){var e=r[t];if(void 0!==e)return e.exports;var s=r[t]={exports:{}};return i[t](s,s.exports,a),s.exports}a.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return a.d(e,{a:e}),e},a.d=(t,e)=>{for(var i in e)a.o(e,i)&&!a.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},a.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var s={};a.d(s,{default:()=>z});var n=a(944),h=/*#__PURE__*/a.n(n),o=a(512),l=/*#__PURE__*/a.n(o);let{pie:p}=l().seriesTypes,{arrayMax:c,arrayMin:d,clamp:g,extend:u,fireEvent:f,merge:M,pick:x}=h();class y extends p{calculateExtremes(){let t,e;let i=this.chart,r=i.plotWidth,a=i.plotHeight,s=this.options,n=2*(s.slicedOffset||0),h=this.getColumn("z"),o=Math.min(r,a)-n,l={},p=this.center||this.getCenter();for(let t of["minPointSize","maxPointSize"]){let e=s[t],i=/%$/.test(e);e=parseInt(e,10),l[t]=i?o*e/100:2*e}this.minPxSize=p[3]+l.minPointSize,this.maxPxSize=g(p[2],p[3]+l.minPointSize,l.maxPointSize),h.length&&(t=x(s.zMin,d(h.filter(this.zValEval))),e=x(s.zMax,c(h.filter(this.zValEval))),this.getRadii(t,e,this.minPxSize,this.maxPxSize))}getRadii(t,e,i,r){let a,s,n;let h=this.getColumn("z"),o=[],l="radius"!==this.options.sizeBy,p=e-t;for(let c=0;c<h.length;c++)(s=this.zValEval(h[c])?h[c]:t)<=t?n=i/2:s>=e?n=r/2:(a=p>0?(s-t)/p:.5,l&&(a=Math.sqrt(a)),n=Math.ceil(i+a*(r-i))/2),o.push(n);this.radii=o}redraw(){this.center=null,super.redraw()}getDataLabelPosition(t,e){let{center:i,options:r}=this,a=t.angle||0,s=this.radii[t.index],n=i[0]+Math.cos(a)*s,h=i[1]+Math.sin(a)*s,o=Math.min((r.slicedOffset||0)+(r.borderWidth||0),e/5);return{distance:e,natural:{x:n+Math.cos(a)*e,y:h+Math.sin(a)*e},computed:{},alignment:t.half?"right":"left",connectorPosition:{breakAt:{x:n+Math.cos(a)*o,y:h+Math.sin(a)*o},touchingSliceAt:{x:n,y:h}}}}translate(t){this.generatePoints();let e=this.options,i=e.slicedOffset,r=e.startAngle||0,a=Math.PI/180*(r-90),s=Math.PI/180*(x(e.endAngle,r+360)-90),n=s-a,h=this.points,o=e.ignoreHiddenPoint,l=0,p,c,d,g,u,M,y;this.startAngleRad=a,this.endAngleRad=s,this.calculateExtremes(),t||(this.center=t=this.getCenter());for(let e=0;e<h.length;e++)M=h[e],y=this.radii[e],p=a+l*n,(!o||M.visible)&&(l+=M.percentage/100),c=a+l*n,M.shapeType="arc",M.shapeArgs={x:t[0],y:t[1],r:y,innerR:t[3]/2,start:Math.round(1e3*p)/1e3,end:Math.round(1e3*c)/1e3},(d=(c+p)/2)>1.5*Math.PI?d-=2*Math.PI:d<-Math.PI/2&&(d+=2*Math.PI),M.slicedTranslation={translateX:Math.round(Math.cos(d)*i),translateY:Math.round(Math.sin(d)*i)},g=Math.cos(d)*t[2]/2,u=Math.sin(d)*t[2]/2,M.tooltipPos=[t[0]+.7*g,t[1]+.7*u],M.half=d<-Math.PI/2||d>Math.PI/2?1:0,M.angle=d;f(this,"afterTranslate")}zValEval(t){return!("number"!=typeof t||isNaN(t))||null}}y.defaultOptions=M(p.defaultOptions,{minPointSize:"10%",maxPointSize:"100%",zMin:void 0,zMax:void 0,sizeBy:"area",tooltip:{pointFormat:'<span style="color:{point.color}">●</span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>'}}),u(y.prototype,{pointArrayMap:["y","z"],parallelArrays:["x","y","z"]}),l().registerSeriesType("variablepie",y);let z=h();return s.default})());
!/**
 * Highstock JS v12.0.1 (2024-11-28)
 * @module highcharts/indicators/macd
 * @requires highcharts
 * @requires highcharts/modules/stock
 *
 * Indicator series type for Highcharts Stock
 *
 * (c) 2010-2024 Sebastian Bochan
 *
 * License: www.highcharts.com/license
 */function(e,s){"object"==typeof exports&&"object"==typeof module?module.exports=s(require("highcharts"),require("highcharts").SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/macd",[["highcharts/highcharts"],["highcharts/highcharts","SeriesRegistry"]],s):"object"==typeof exports?exports["highcharts/macd"]=s(require("highcharts"),require("highcharts").SeriesRegistry):e.Highcharts=s(e.Highcharts,e.Highcharts.SeriesRegistry)}(this,(e,s)=>(()=>{"use strict";var t={512:e=>{e.exports=s},944:s=>{s.exports=e}},o={};function i(e){var s=o[e];if(void 0!==s)return s.exports;var r=o[e]={exports:{}};return t[e](r,r.exports,i),r.exports}i.n=e=>{var s=e&&e.__esModule?()=>e.default:()=>e;return i.d(s,{a:s}),s},i.d=(e,s)=>{for(var t in s)i.o(s,t)&&!i.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:s[t]})},i.o=(e,s)=>Object.prototype.hasOwnProperty.call(e,s);var r={};i.d(r,{default:()=>f});var n=i(944),a=/*#__PURE__*/i.n(n),l=i(512),p=/*#__PURE__*/i.n(l);let{noop:h}=a(),{column:d,sma:g}=p().seriesTypes,{extend:c,correctFloat:y,defined:u,merge:m}=a();class x extends g{init(){p().seriesTypes.sma.prototype.init.apply(this,arguments);let e=this.color;this.options&&(u(this.colorIndex)&&(this.options.signalLine&&this.options.signalLine.styles&&!this.options.signalLine.styles.lineColor&&(this.options.colorIndex=this.colorIndex+1,this.getCyclic("color",void 0,this.chart.options.colors),this.options.signalLine.styles.lineColor=this.color),this.options.macdLine&&this.options.macdLine.styles&&!this.options.macdLine.styles.lineColor&&(this.options.colorIndex=this.colorIndex+1,this.getCyclic("color",void 0,this.chart.options.colors),this.options.macdLine.styles.lineColor=this.color)),this.macdZones={zones:this.options.macdLine.zones,startIndex:0},this.signalZones={zones:this.macdZones.zones.concat(this.options.signalLine.zones),startIndex:this.macdZones.zones.length}),this.color=e}toYData(e){return[e.y,e.signal,e.MACD]}translate(){let e=this,s=["plotSignal","plotMACD"];a().seriesTypes.column.prototype.translate.apply(e),e.points.forEach(function(t){[t.signal,t.MACD].forEach(function(o,i){null!==o&&(t[s[i]]=e.yAxis.toPixels(o,!0))})})}destroy(){this.graph=null,this.graphmacd=this.graphmacd&&this.graphmacd.destroy(),this.graphsignal=this.graphsignal&&this.graphsignal.destroy(),p().seriesTypes.sma.prototype.destroy.apply(this,arguments)}drawGraph(){let e=this,s=e.points,t=e.options,o=e.zones,i={options:{gapSize:t.gapSize}},r=[[],[]],n,a=s.length;for(;a--;)u((n=s[a]).plotMACD)&&r[0].push({plotX:n.plotX,plotY:n.plotMACD,isNull:!u(n.plotMACD)}),u(n.plotSignal)&&r[1].push({plotX:n.plotX,plotY:n.plotSignal,isNull:!u(n.plotMACD)});["macd","signal"].forEach((s,o)=>{e.points=r[o],e.options=m(t[`${s}Line`]?.styles||{},i),e.graph=e[`graph${s}`],e.zones=(e[`${s}Zones`].zones||[]).slice(e[`${s}Zones`].startIndex||0),p().seriesTypes.sma.prototype.drawGraph.call(e),e[`graph${s}`]=e.graph}),e.points=s,e.options=t,e.zones=o}applyZones(){let e=this.zones;this.zones=this.signalZones.zones,p().seriesTypes.sma.prototype.applyZones.call(this),this.graphmacd&&this.options.macdLine.zones.length&&this.graphmacd.hide(),this.zones=e}getValues(e,s){let t=s.longPeriod-s.shortPeriod,o=[],i=[],r=[],n,a,l,h=0,d=[];if(!(e.xData.length<s.longPeriod+s.signalPeriod)){for(l=0,n=p().seriesTypes.ema.prototype.getValues(e,{period:s.shortPeriod,index:s.index}),a=p().seriesTypes.ema.prototype.getValues(e,{period:s.longPeriod,index:s.index}),n=n.values,a=a.values;l<=n.length;l++)u(a[l])&&u(a[l][1])&&u(n[l+t])&&u(n[l+t][0])&&o.push([n[l+t][0],0,null,n[l+t][1]-a[l][1]]);for(l=0;l<o.length;l++)i.push(o[l][0]),r.push([0,null,o[l][3]]);for(l=0,d=(d=p().seriesTypes.ema.prototype.getValues({xData:i,yData:r},{period:s.signalPeriod,index:2})).values;l<o.length;l++)o[l][0]>=d[0][0]&&(o[l][2]=d[h][1],r[l]=[0,d[h][1],o[l][3]],null===o[l][3]?(o[l][1]=0,r[l][0]=0):(o[l][1]=y(o[l][3]-d[h][1]),r[l][0]=y(o[l][3]-d[h][1])),h++);return{values:o,xData:i,yData:r}}}}x.defaultOptions=m(g.defaultOptions,{params:{shortPeriod:12,longPeriod:26,signalPeriod:9,period:26},signalLine:{zones:[],styles:{lineWidth:1,lineColor:void 0}},macdLine:{zones:[],styles:{lineWidth:1,lineColor:void 0}},threshold:0,groupPadding:.1,pointPadding:.1,crisp:!1,states:{hover:{halo:{size:0}}},tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>Value: {point.MACD}<br/>Signal: {point.signal}<br/>Histogram: {point.y}<br/>'},dataGrouping:{approximation:"averages"},minPointLength:0}),c(x.prototype,{nameComponents:["longPeriod","shortPeriod","signalPeriod"],pointArrayMap:["y","signal","MACD"],parallelArrays:["x","y","signal","MACD"],pointValKey:"y",markerAttribs:h,getColumnMetrics:a().seriesTypes.column.prototype.getColumnMetrics,crispCol:a().seriesTypes.column.prototype.crispCol,drawPoints:a().seriesTypes.column.prototype.drawPoints}),p().registerSeriesType("macd",x);let f=a();return r.default})());
!/**
 * Highstock JS v12.0.1 (2024-11-28)
 * @module highcharts/indicators/indicators
 * @requires highcharts
 * @requires highcharts/modules/stock
 *
 * Indicator series type for Highcharts Stock
 *
 * (c) 2010-2024 Pawel Fus, Sebastian Bochan
 *
 * License: www.highcharts.com/license
 */function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("highcharts"),require("highcharts").Chart,require("highcharts").SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/indicators",[["highcharts/highcharts"],["highcharts/highcharts","Chart"],["highcharts/highcharts","SeriesRegistry"]],e):"object"==typeof exports?exports["highcharts/indicators"]=e(require("highcharts"),require("highcharts").Chart,require("highcharts").SeriesRegistry):t.Highcharts=e(t.Highcharts,t.Highcharts.Chart,t.Highcharts.SeriesRegistry)}(this,(t,e,a)=>(()=>{"use strict";var i,s={960:t=>{t.exports=e},512:t=>{t.exports=a},944:e=>{e.exports=t}},r={};function n(t){var e=r[t];if(void 0!==e)return e.exports;var a=r[t]={exports:{}};return s[t](a,a.exports,n),a.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var a in e)n.o(e,a)&&!n.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:e[a]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var o={};n.d(o,{default:()=>L});var l=n(944),h=/*#__PURE__*/n.n(l),p=n(960),u=/*#__PURE__*/n.n(p),d=n(512),c=/*#__PURE__*/n.n(d);let{line:f}=c().seriesTypes,{addEvent:g,fireEvent:m,error:x,extend:y,isArray:D,merge:P,pick:C}=h(),v=(t,e)=>{let a=[],i=t.pointArrayMap,s=e&&t.dataTable.modified||t.dataTable;if(!i)return t.getColumn("y",e);let r=i.map(a=>t.getColumn(a,e));for(let t=0;t<s.rowCount;t++){let e=i.map((e,a)=>r[a]?.[t]||0);a.push(e)}return a};class A extends f{destroy(){this.dataEventsToUnbind.forEach(function(t){t()}),super.destroy.apply(this,arguments)}getName(){let t=[],e=this.name;return e||((this.nameComponents||[]).forEach(function(e,a){t.push(this.options.params[e]+C(this.nameSuffixes[a],""))},this),e=(this.nameBase||this.type.toUpperCase())+(this.nameComponents?" ("+t.join(", ")+")":"")),e}getValues(t,e){let a=e.period,i=t.xData||[],s=t.yData,r=s.length,n=[],o=[],l=[],h,p=-1,u=0,d,c=0;if(!(i.length<a)){for(D(s[0])&&(p=e.index?e.index:0);u<a-1;)c+=p<0?s[u]:s[u][p],u++;for(h=u;h<r;h++)c+=p<0?s[h]:s[h][p],d=[i[h],c/a],n.push(d),o.push(d[0]),l.push(d[1]),c-=p<0?s[h-u]:s[h-u][p];return{values:n,xData:o,yData:l}}}init(t,e){let a=this;super.init.call(a,t,e);let i=g(u(),"afterLinkSeries",function({isUpdating:e}){if(e)return;let i=!!a.dataEventsToUnbind.length;if(!a.linkedParent)return x("Series "+a.options.linkedTo+" not found! Check `linkedTo`.",!1,t);if(!i&&(a.dataEventsToUnbind.push(g(a.linkedParent,"updatedData",function(){a.recalculateValues()})),a.calculateOn.xAxis&&a.dataEventsToUnbind.push(g(a.linkedParent.xAxis,a.calculateOn.xAxis,function(){a.recalculateValues()}))),"init"===a.calculateOn.chart)a.closestPointRange||a.recalculateValues();else if(!i){let t=g(a.chart,a.calculateOn.chart,function(){a.recalculateValues(),t()})}},{order:0});a.dataEventsToUnbind=[],a.eventsToUnbind.push(i)}recalculateValues(){let t=[],e=this.dataTable,a=this.points||[],i=this.dataTable.rowCount,s=!0,r,n,o,l,h=this.linkedParent.yData,p=this.linkedParent.processedYData;this.linkedParent.xData=this.linkedParent.getColumn("x"),this.linkedParent.yData=v(this.linkedParent),this.linkedParent.processedYData=v(this.linkedParent,!0);let u=this.linkedParent.options&&this.linkedParent.dataTable.rowCount&&this.getValues(this.linkedParent,this.options.params)||{values:[],xData:[],yData:[]};delete this.linkedParent.xData,this.linkedParent.yData=h,this.linkedParent.processedYData=p;let d=this.pointArrayMap||["y"],c={};if(u.yData.forEach(t=>{d.forEach((e,a)=>{let i=c[e]||[];i.push(D(t)?t[a]:t),c[e]||(c[e]=i)})}),i&&!this.hasGroupedData&&this.visible&&this.points){if(this.cropped){this.xAxis&&(o=this.xAxis.min,l=this.xAxis.max);let i=this.cropData(e,o,l),s=["x",...this.pointArrayMap||["y"]];for(let e=0;e<(i.modified?.rowCount||0);e++){let a=s.map(t=>this.getColumn(t)[e]||0);t.push(a)}let h=this.getColumn("x");r=u.xData.indexOf(h[0]),n=u.xData.indexOf(h[h.length-1]),-1===r&&n===u.xData.length-2&&t[0][0]===a[0].x&&t.shift(),this.updateData(t)}else(this.updateAllPoints||u.xData.length!==i-1&&u.xData.length!==i+1)&&(s=!1,this.updateData(u.values))}s&&(e.setColumns({...c,x:u.xData}),this.options.data=u.values),this.calculateOn.xAxis&&this.getColumn("x",!0).length&&(this.isDirty=!0,this.redraw()),this.isDirtyData=!!this.linkedSeries.length,m(this,"updatedData")}processData(){let t=this.options.compareToMain,e=this.linkedParent;super.processData.apply(this,arguments),this.dataModify&&e&&e.dataModify&&e.dataModify.compareValue&&t&&(this.dataModify.compareValue=e.dataModify.compareValue)}}A.defaultOptions=P(f.defaultOptions,{name:void 0,tooltip:{valueDecimals:4},linkedTo:void 0,compareToMain:!1,params:{index:3,period:14}}),y(A.prototype,{calculateOn:{chart:"init"},hasDerivedData:!0,nameComponents:["period"],nameSuffixes:[],useCommonDataGrouping:!0}),c().registerSeriesType("sma",A);let{sma:k}=c().seriesTypes,{correctFloat:T,isArray:M,merge:O}=h();class b extends k{accumulatePeriodPoints(t,e,a){let i=0,s=0;for(;s<t;)i+=e<0?a[s]:a[s][e],s++;return i}calculateEma(t,e,a,i,s,r,n){let o=t[a-1],l=r<0?e[a-1]:e[a-1][r];return[o,void 0===s?n:T(l*i+s*(1-i))]}getValues(t,e){let a=e.period,i=t.xData,s=t.yData,r=s?s.length:0,n=2/(a+1),o=[],l=[],h=[],p,u,d,c=-1,f=0;if(!(r<a)){for(M(s[0])&&(c=e.index?e.index:0),f=this.accumulatePeriodPoints(a,c,s)/a,d=a;d<r+1;d++)u=this.calculateEma(i,s,d,n,p,c,f),o.push(u),l.push(u[0]),h.push(u[1]),p=u[1];return{values:o,xData:l,yData:h}}}}b.defaultOptions=O(k.defaultOptions,{params:{index:3,period:9}}),c().registerSeriesType("ema",b);let{sma:{prototype:E}}=c().seriesTypes,{defined:S,error:V,merge:G}=h();!function(t){let e=["bottomLine"],a=["top","bottom"],i=["top"];function s(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function r(t,e){let a=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&a.push(s(t))}),a}function n(){let t=this,e=t.pointValKey,a=t.linesApiNames,i=t.areaLinesNames,n=t.points,o=t.options,l=t.graph,h={options:{gapSize:o.gapSize}},p=[],u=r(t,e),d=n.length,c;if(u.forEach((t,e)=>{for(p[e]=[];d--;)c=n[d],p[e].push({x:c.x,plotX:c.plotX,plotY:c[t],isNull:!S(c[t])});d=n.length}),t.userOptions.fillColor&&i.length){let e=p[u.indexOf(s(i[0]))],a=1===i.length?n:p[u.indexOf(s(i[1]))],r=t.color;t.points=a,t.nextPoints=e,t.color=t.userOptions.fillColor,t.options=G(n,h),t.graph=t.area,t.fillGraph=!0,E.drawGraph.call(t),t.area=t.graph,delete t.nextPoints,delete t.fillGraph,t.color=r}a.forEach((e,a)=>{p[a]?(t.points=p[a],o[e]?t.options=G(o[e].styles,h):V('Error: "There is no '+e+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),t.graph=t["graph"+e],E.drawGraph.call(t),t["graph"+e]=t.graph):V('Error: "'+e+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),t.points=n,t.options=o,t.graph=l,E.drawGraph.call(t)}function o(t){let e,a=[],i=[];if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=E.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]="L",a=E.getGraphPath.call(this,t),i=e.slice(0,a.length);for(let t=i.length-1;t>=0;t--)a.push(i[t])}}else a=E.getGraphPath.apply(this,arguments);return a}function l(t){let e=[];return(this.pointArrayMap||[]).forEach(a=>{e.push(t[a])}),e}function h(){let t=this.pointArrayMap,e=[],a;e=r(this),E.translate.apply(this,arguments),this.points.forEach(i=>{t.forEach((t,s)=>{a=i[t],this.dataModify&&(a=this.dataModify.modifyValue(a)),null!==a&&(i[e[s]]=this.yAxis.toPixels(a,!0))})})}t.compose=function(t){let s=t.prototype;return s.linesApiNames=s.linesApiNames||e.slice(),s.pointArrayMap=s.pointArrayMap||a.slice(),s.pointValKey=s.pointValKey||"top",s.areaLinesNames=s.areaLinesNames||i.slice(),s.drawGraph=n,s.getGraphPath=o,s.toYData=l,s.translate=h,t}}(i||(i={}));let w=i,N=h();N.MultipleLinesComposition=N.MultipleLinesComposition||w;let L=h();return o.default})());
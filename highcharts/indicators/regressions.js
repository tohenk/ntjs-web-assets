!/**
 * Highstock JS v12.0.1 (2024-11-28)
 * @module highcharts/indicators/regressions
 * @requires highcharts
 * @requires highcharts/modules/stock
 *
 * Indicator series type for Highcharts Stock
 *
 * (c) 2010-2024 Kamil Kulig
 *
 * License: www.highcharts.com/license
 */function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("highcharts"),require("highcharts").SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/regressions",[["highcharts/highcharts"],["highcharts/highcharts","SeriesRegistry"]],t):"object"==typeof exports?exports["highcharts/regressions"]=t(require("highcharts"),require("highcharts").SeriesRegistry):e.Highcharts=t(e.Highcharts,e.Highcharts.SeriesRegistry)}(this,(e,t)=>(()=>{"use strict";var r={512:e=>{e.exports=t},944:t=>{t.exports=e}},s={};function n(e){var t=s[e];if(void 0!==t)return t.exports;var i=s[e]={exports:{}};return r[e](i,i.exports,n),i.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var i={};n.d(i,{default:()=>I});var a=n(944),o=/*#__PURE__*/n.n(a),l=n(512),p=/*#__PURE__*/n.n(l);let{sma:g}=p().seriesTypes,{isArray:h,extend:u,merge:c}=o();class d extends g{getRegressionLineParameters(e,t){let r=this.options.params.index,s=function(e,t){return h(e)?e[t]:e},n=e.reduce(function(e,t){return t+e},0),i=t.reduce(function(e,t){return s(t,r)+e},0),a=n/e.length,o=i/t.length,l,p,g=0,u=0;for(p=0;p<e.length;p++)g+=(l=e[p]-a)*(s(t[p],r)-o),u+=Math.pow(l,2);let c=u?g/u:0;return{slope:c,intercept:o-c*a}}getEndPointY(e,t){return e.slope*t+e.intercept}transformXData(e,t){let r=e[0];return e.map(function(e){return(e-r)/t})}findClosestDistance(e){let t,r,s;for(s=1;s<e.length-1;s++)(t=e[s]-e[s-1])>0&&(void 0===r||t<r)&&(r=t);return r}getValues(e,t){let r,s,n,i,a,o,l,p,g;let u=e.xData,c=e.yData,d=t.period,f={xData:[],yData:[],values:[]},y=this.options.params.xAxisUnit||this.findClosestDistance(u);for(s=d-1;s<=u.length-1;s++)n=s-d+1,i=s+1,a=u[s],l=u.slice(n,i),p=c.slice(n,i),g=this.transformXData(l,y),r=this.getRegressionLineParameters(g,p),o=this.getEndPointY(r,g[g.length-1]),f.values.push({regressionLineParameters:r,x:a,y:o}),h(f.xData)&&f.xData.push(a),h(f.yData)&&f.yData.push(o);return f}}d.defaultOptions=c(g.defaultOptions,{params:{xAxisUnit:null},tooltip:{valueDecimals:4}}),u(d.prototype,{nameBase:"Linear Regression Indicator"}),p().registerSeriesType("linearRegression",d);let{linearRegression:f}=p().seriesTypes,{extend:y,merge:x}=o();class m extends f{getEndPointY(e){return e.slope}}m.defaultOptions=x(f.defaultOptions),y(m.prototype,{nameBase:"Linear Regression Slope Indicator"}),p().registerSeriesType("linearRegressionSlope",m);let{linearRegression:R}=p().seriesTypes,{extend:D,merge:v}=o();class O extends R{getEndPointY(e){return e.intercept}}O.defaultOptions=v(R.defaultOptions),D(O.prototype,{nameBase:"Linear Regression Intercept Indicator"}),p().registerSeriesType("linearRegressionIntercept",O);let{linearRegression:P}=p().seriesTypes,{extend:S,merge:T}=o();class b extends P{slopeToAngle(e){return 180/Math.PI*Math.atan(e)}getEndPointY(e){return this.slopeToAngle(e.slope)}}b.defaultOptions=T(P.defaultOptions,{tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span>{series.name}: <b>{point.y}\xb0</b><br/>'}}),S(b.prototype,{nameBase:"Linear Regression Angle Indicator"}),p().registerSeriesType("linearRegressionAngle",b);let I=o();return i.default})());